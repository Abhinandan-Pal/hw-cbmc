/*******************************************************************\

Module: EBMC's Factory for Word-Level Solvers

Author: Daniel Kroening, dkr@amazon.com

\*******************************************************************/

#include "ebmc_solver_factory.h"

#include <util/make_unique.h>
#include <util/unicode.h>

#include <solvers/flattening/boolbv.h>
#include <solvers/prop/prop.h>
#include <solvers/sat/satcheck.h>
#include <solvers/smt2/smt2_dec.h>

#include "ebmc_error.h"
#include "ebmc_version.h"
#include "show_formula_solver.h"

#include <fstream>
#include <iostream>

std::function<ebmc_solvert(const namespacet &, message_handlert &)>
ebmc_solver_factory(const cmdlinet &cmdline)
{
  if(cmdline.isset("show-formula"))
  {
    if(cmdline.isset("outfile"))
    {
      const std::string filename = cmdline.get_value("outfile");

      return [filename](const namespacet &ns, message_handlert &message_handler)
      {
        std::unique_ptr<std::ofstream> outfile_ptr{
          new std::ofstream(widen_if_needed(filename))};

        if(!*outfile_ptr)
          throw ebmc_errort() << "Failed to open `" << filename << "'";

        messaget message(message_handler);
        message.status() << "Writing formula to `" << filename << "'"
                         << messaget::eom;

        auto dec = util_make_unique<show_formula_solvert>(*outfile_ptr);

        return ebmc_solvert{std::move(outfile_ptr), std::move(dec)};
      };
    }
    else
    {
      return [](const namespacet &, message_handlert &)
      {
        auto dec = util_make_unique<show_formula_solvert>(std::cout);
        return ebmc_solvert{std::move(dec)};
      };
    }
  }

  optionalt<smt2_convt::solvert> smt2_solver =
    cmdline.isset("bitwuzla")    ? smt2_convt::solvert::BITWUZLA
    : cmdline.isset("boolector") ? smt2_convt::solvert::BOOLECTOR
    : cmdline.isset("cvc3")      ? smt2_convt::solvert::CVC3
    : cmdline.isset("cvc4")      ? smt2_convt::solvert::CVC4
    : cmdline.isset("cvc5")      ? smt2_convt::solvert::CVC5
    : cmdline.isset("mathsat")   ? smt2_convt::solvert::MATHSAT
    : cmdline.isset("yices")     ? smt2_convt::solvert::YICES
    : cmdline.isset("z3")        ? smt2_convt::solvert::Z3
    : cmdline.isset("smt2")      ? smt2_convt::solvert::GENERIC
                                 : optionalt<smt2_convt::solvert>{};

  if(cmdline.isset("outfile"))
  {
    const std::string filename = cmdline.get_value("outfile");

    if(smt2_solver.has_value())
    {
      return [filename, smt2_solver](
               const namespacet &ns, message_handlert &message_handler)
      {
        std::unique_ptr<std::ofstream> outfile_ptr{
          new std::ofstream(widen_if_needed(filename))};

        if(!*outfile_ptr)
          throw ebmc_errort() << "Failed to open `" << filename << "'";

        messaget message(message_handler);
        message.status() << "Writing SMT2 formula to `" << filename << "'"
                         << messaget::eom;

        auto dec = util_make_unique<smt2_convt>(
          ns,
          "ebmc",
          "Generated by EBMC " EBMC_VERSION,
          "QF_AUFBV",
          smt2_solver.value(),
          *outfile_ptr);

        return ebmc_solvert{std::move(outfile_ptr), std::move(dec)};
      };
    }
    else
    {
      // We are given --outfile without an SMT-solver option.
      throw ebmc_errort()
        << "Cannot write to an output file without file format option";
    }
  }

  if(smt2_solver.has_value())
  {
    return
      [smt2_solver](const namespacet &ns, message_handlert &message_handler)
    {
      return ebmc_solvert{util_make_unique<smt2_dect>(
        ns,
        "ebmc",
        "Generated by EBMC " EBMC_VERSION,
        "QF_AUFBV",
        smt2_solver.value(),
        message_handler)};
    };
  }
  else
  {
    // the 'default' solver
    return [](const namespacet &ns, message_handlert &message_handler)
    {
      auto prop = std::unique_ptr<propt>(new satcheckt{message_handler});

      messaget message(message_handler);
      message.status() << "Using " << prop->solver_text() << messaget::eom;

      auto dec = std::unique_ptr<stack_decision_proceduret>(
        new boolbvt{ns, *prop, message_handler});

      return ebmc_solvert{std::move(prop), std::move(dec)};
    };
  }
}
