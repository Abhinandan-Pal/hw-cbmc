/*******************************************************************\

Module: EBMC's Solvers

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <fstream>

#include <i2string.h>
#include <cmdline.h>

#include <trans/compute_ct.h>

#include <solvers/cvc/cvc_dec.h>
#include <solvers/dplib/dplib_dec.h>
#include <solvers/smt1/smt1_dec.h>
#include <solvers/smt2/smt2_dec.h>
#include <solvers/flattening/boolbv.h>
#include <solvers/sat/dimacs_cnf.h>
#include <solvers/sat/satcheck.h>

#ifdef HAVE_PROVER
#include <prover/prover_sat.h>
#include <prover/lifter.h>
#endif

#include "ebmc_base.h"
#include "version.h"

/*******************************************************************\

Function: ebmc_baset::do_dimacs

  Inputs:

 Outputs:

 Purpose: invoke main modules

\*******************************************************************/

int ebmc_baset::do_dimacs()
{
  dimacs_cnft dimacs_cnf;
  int result=do_ebmc(dimacs_cnf, true);
  if(result!=0) return result;

  {
    std::string stat_text=
      i2string(dimacs_cnf.no_variables())+" variables and "+
      i2string(dimacs_cnf.no_clauses())+" clauses";
    status(stat_text);
  }

  if(cmdline.isset("outfile"))
  {
    const char *filename=cmdline.getval("outfile");
    std::ofstream out(filename);
  
    if(!out)
    {
      std::cerr << "Failed to open `"
                << filename
                << "'" << std::endl;
      return 1;
    }

    dimacs_cnf.write_dimacs_cnf(out);
  }
  else
    dimacs_cnf.write_dimacs_cnf(std::cout);

  return 0;
}

/*******************************************************************\

Function: ebmc_baset::do_dplib

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_dplib()
{
  const namespacet ns(symbol_table);

  if(cmdline.isset("outfile"))
  {
    const char *filename=cmdline.getval("outfile");
    std::ofstream out(filename);
  
    if(!out)
    {
      std::cerr << "Failed to open `"
                << filename
                << "'" << std::endl;
      return 1;
    }

    dplib_convt dplib_conv(ns, out);
    return do_ebmc(dplib_conv, true);
  }

  dplib_dect dplib_dec(ns);
  return do_ebmc(dplib_dec, false);
}

/*******************************************************************\

Function: ebmc_baset::do_smt1

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_smt1()
{
  const namespacet ns(symbol_table);

  if(cmdline.isset("outfile"))
  {
    const char *filename=cmdline.getval("outfile");
    std::ofstream out(filename);
  
    if(!out)
    {
      std::cerr << "Failed to open `"
                << filename
                << "'" << std::endl;
      return 1;
    }

    smt1_convt smt1_conv(
      ns,
      "ebmc",
      "Generated by EBMC " EBMC_VERSION,
      "QF_AUFBV",
      out);
     
    return do_ebmc(smt1_conv, true);
  }

  smt1_convt smt1_conv(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    std::cout);
   
  return do_ebmc(smt1_conv, true);
}

/*******************************************************************\

Function: ebmc_baset::do_smt2

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_smt2()
{
  const namespacet ns(symbol_table);

  if(cmdline.isset("outfile"))
  {
    const char *filename=cmdline.getval("outfile");
    std::ofstream out(filename);
  
    if(!out)
    {
      std::cerr << "Failed to open `"
                << filename
                << "'" << std::endl;
      return 1;
    }

    smt2_convt smt2_conv(
      ns,
      "ebmc",
      "Generated by EBMC " EBMC_VERSION,
      "QF_AUFBV",
      out);
     
    return do_ebmc(smt2_conv, true);
  }

  smt2_convt smt2_conv(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    std::cout);
   
  return do_ebmc(smt2_conv, true);
}

/*******************************************************************\

Function: ebmc_baset::do_z3

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_z3()
{
  const namespacet ns(symbol_table);

  smt1_dect smt1_dec(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    smt1_dect::Z3);
                     
  return do_ebmc(smt1_dec, false);
}

/*******************************************************************\

Function: ebmc_baset::do_cvc3

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_cvc3()
{
  const namespacet ns(symbol_table);

  smt1_dect smt1_dec(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    smt1_dect::CVC3);
                     
  return do_ebmc(smt1_dec, false);
}

/*******************************************************************\

Function: ebmc_baset::do_yices

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_yices()
{
  const namespacet ns(symbol_table);
  
  smt1_dect smt1_dec(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    smt1_dect::YICES);
                     
  return do_ebmc(smt1_dec, false);
}

/*******************************************************************\

Function: ebmc_baset::do_boolector

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_boolector()
{
  const namespacet ns(symbol_table);

  smt1_dect smt1_dec(
    ns,
    "ebmc",
    "Generated by EBMC " EBMC_VERSION,
    "QF_AUFBV",
    smt1_dect::BOOLECTOR);
                     
  return do_ebmc(smt1_dec, false);
}

/*******************************************************************\

Function: ebmc_baset::do_sat

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_sat()
{
  satcheckt satcheck;

  if(cmdline.isset("no-netlist"))
  {
    const namespacet ns(symbol_table);
    boolbvt boolbv(ns, satcheck);
    return do_ebmc(boolbv, false);
  }
  else
    return do_ebmc(satcheck, false);
}

/*******************************************************************\

Function: ebmc_baset::do_prover

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_prover()
{
  #ifdef HAVE_PROVER
  const namespacet ns(symbol_table);
  prover_satt prover_sat(ns);
  return do_ebmc(prover_sat, false);
  #else
  error("Support for prover not linked in");
  return 1;
  #endif
}

/*******************************************************************\

Function: ebmc_baset::do_lifter

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_lifter()
{
  #ifdef HAVE_PROVER
  const namespacet ns(symbol_table);
  liftert lifter(ns);
  return do_ebmc(lifter.prop_conv(), false);
  #else
  error("Support for lifter not linked in");
  return 1;
  #endif
}

/*******************************************************************\

Function: ebmc_baset::do_compute_ct

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

int ebmc_baset::do_compute_ct()
{
  // make net-list
  status("Making Netlist");

  netlistt netlist;
  make_netlist(netlist);

  status("Latches: "+i2string(netlist.var_map.latches.size())+
         ", nodes: "+i2string(netlist.number_of_nodes()));

  status("Making LDG");
  
  ldgt ldg;
  ldg.compute(netlist);

  std::cout << "CT = " << compute_ct(ldg) << std::endl;
  
  return 0;
}

